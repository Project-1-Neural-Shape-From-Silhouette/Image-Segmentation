# -*- coding: utf-8 -*-
"""segmentation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_NxzE0mJO3P0_6TLZAaEZgRiC6glO-FC
"""

from google.colab import drive
import cv2
import numpy as np
import os
import matplotlib.pyplot as plt

# Mount Google Drive
drive.mount('/content/drive')

# Set input and output directory paths
input_dir = '/content/drive/My Drive/Colab Notebooks/HTCV/mic/train'
output_dir = '/content/drive/My Drive/Colab Notebooks/HTCV/mic/segmented_images'
os.makedirs(output_dir, exist_ok=True)

# Get all image files in the input directory
image_paths = [os.path.join(input_dir, f) for f in os.listdir(input_dir) if f.endswith('.png')]

# Segment images and save the results
for image_path in image_paths:
    # Read the image
    image = cv2.imread(image_path)

    if image is None:
        raise FileNotFoundError(f"Unable to read the image, please check if the path is correct: {image_path}")

    # Create mask and background model
    mask = np.zeros(image.shape[:2], np.uint8)
    bgd_model = np.zeros((1, 65), np.float64)
    fgd_model = np.zeros((1, 65), np.float64)

    # Define the rectangle for foreground and background
    rect = (10, 10, image.shape[1] - 20, image.shape[0] - 20)

    # Apply GrabCut algorithm
    cv2.grabCut(image, mask, rect, bgd_model, fgd_model, 5, cv2.GC_INIT_WITH_RECT)

    # Convert mask to binary image
    mask2 = np.where((mask == 2) | (mask == 0), 0, 1).astype('uint8')

    # Apply mask to the image
    result = image * mask2[:, :, np.newaxis]

    # Save the result
    result_path = os.path.join(output_dir, os.path.basename(image_path).replace(".png", "_segmented.png"))
    cv2.imwrite(result_path, result)

print("Image segmentation processing completed.")

# Get all segmented image files in the output directory
segmented_image_paths = [os.path.join(output_dir, f) for f in os.listdir(output_dir) if f.endswith('_segmented.png')]

# Display segmented images
for segmented_image_path in segmented_image_paths:
    # Read the segmented image
    segmented_image = cv2.imread(segmented_image_path)

    if segmented_image is None:
        raise FileNotFoundError(f"Unable to read the segmented image, please check if the path is correct: {segmented_image_path}")

    # Convert to RGB image for displaying with matplotlib
    segmented_image_rgb = cv2.cvtColor(segmented_image, cv2.COLOR_BGR2RGB)

    # Display image
    plt.figure()
    plt.imshow(segmented_image_rgb)
    plt.title(os.path.basename(segmented_image_path))
    plt.axis('off')  # Turn off axis display
    plt.show()

print("Segmented images display completed.")

# Binary image processing section
# Get input and output directory paths
input_dir = '/content/drive/My Drive/Colab Notebooks/HTCV/mic/train'
output_dir = '/content/drive/My Drive/Colab Notebooks/HTCV/mic/segmented_images'
os.makedirs(output_dir, exist_ok=True)

# Get all image files in the input directory
image_paths = [os.path.join(input_dir, f) for f in os.listdir(input_dir) if f.endswith('.png')]

# Segment images and save binary results
for image_path in image_paths:
    # Read the image
    image = cv2.imread(image_path)

    if image is None:
        raise FileNotFoundError(f"Unable to read the image, please check if the path is correct: {image_path}")

    # Create mask and background model
    mask = np.zeros(image.shape[:2], np.uint8)
    bgd_model = np.zeros((1, 65), np.float64)
    fgd_model = np.zeros((1, 65), np.float64)

    # Define the rectangle for foreground and background
    rect = (10, 10, image.shape[1] - 20, image.shape[0] - 20)

    # Apply GrabCut algorithm
    cv2.grabCut(image, mask, rect, bgd_model, fgd_model, 5, cv2.GC_INIT_WITH_RECT)

    # Convert mask to binary image
    mask2 = np.where((mask == 2) | (mask == 0), 0, 1).astype('uint8')

    # Generate binary image
    binary_image = mask2 * 255

    # Save the result
    result_path = os.path.join(output_dir, os.path.basename(image_path).replace(".png", "_binary.png"))
    cv2.imwrite(result_path, binary_image)

print("Image segmentation processing completed.")

# Get all binary image files in the output directory
binary_image_paths = [os.path.join(output_dir, f) for f in os.listdir(output_dir) if f.endswith('_binary.png')]

# Display original and binary images
for binary_image_path in binary_image_paths:
    # Read binary image
    binary_image = cv2.imread(binary_image_path, cv2.IMREAD_GRAYSCALE)

    if binary_image is None:
        raise FileNotFoundError(f"Unable to read binary image, please check if the path is correct: {binary_image_path}")

    # Get the corresponding original image path
    original_image_path = os.path.join(input_dir, os.path.basename(binary_image_path).replace("_binary.png", ".png"))
    original_image = cv2.imread(original_image_path)

    if original_image is None:
        raise FileNotFoundError(f"Unable to read original image, please check if the path is correct: {original_image_path}")

    # Convert to RGB image for displaying with matplotlib
    original_image_rgb = cv2.cvtColor(original_image, cv2.COLOR_BGR2RGB)

    # Create subplots for displaying
    plt.figure(figsize=(12, 6))

    # Display original image
    plt.subplot(1, 2, 1)
    plt.imshow(original_image_rgb)
    plt.title(f"Original Image: {os.path.basename(original_image_path)}")
    plt.axis('off')  # Turn off axis display

    # Display binary image
    plt.subplot(1, 2, 2)
    plt.imshow(binary_image, cmap='gray')
    plt.title(f"Binary Image: {os.path.basename(binary_image_path)}")
    plt.axis('off')  # Turn off axis display

    # Show images
    plt.show()

print("Display of original and segmented binary images completed.")
